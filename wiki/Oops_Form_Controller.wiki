#summary Шаблон проектирования "Контроллер форм"
#labels Featured


= Коротко о главном =

Большинство интерактивных элементов реализуют однотипную логику работы, а именно:

  * есть 3 обязательных шага в любом таком процессе
    # отображение формы ввода (точки воздействия);
    # проверка поступивших данных и
    # сохранение данных
  * выполнение процедуры может быть прервано на этапе отображения (нет доступа, не соблюдены какие-то входные условия) и на этапе проверки (данные не соответствуют модели)


Таким образом, для реализации логики можно использовать типовой элемент, использующий событийную модель. Перед отображением формы и перед сохранением данных генерируются события, к которым прикрепляется запрос пользователя, и которые могут быть отменены с указанием ошибки, и к которым могут быть прикреплены дополнительные данные для отображения. Само по себе сохранение данных также инициируется событием (для стройности).


= Логика работы =
Контроллер формы инициируется из интерфейсного класса и получает на вход 2 параметра - массив "запрос пользователя" и флаг "делать обновление". В качестве запроса пользователя можно передать как все параметры запроса пришедшего в скрипт, так и его часть (удобно когда есть несколько частей в одной форме), так и вообще произвольный массив (например, если нужно что-то сделать не в онлайн, а из какого-нибудь скрипта).

Первым делом после запуска, независимо от флага обновления, формируется событие onBeforeFormShow. В качестве сопроводительных данных к событию прикрепляется запрос пользователя (как и ко всем другим событиям). Обозреватели этого события должны (точнее, могут):

    * проверить входные условия, в т.ч. данные из запроса
    * отменить событие если произошла ошибка (не пройдена проверка), с указанием ошибки и сопроводительных данных
    * прикрепить в событию данные, требуемые для отображения формы

После прохода события по обозревателям (диспетчеризации), событие анализируется, из него извлекаются данные, если таковые были прикреплены обозревателями, и проверяется статус отмены события. Если событие _onBeforeFormShow_ было отменено то выполнение контроллера завершается, собранные данные и ошибки возвращаются инициатору. То же самое происходит если флаг обновления не взведен.

Затем, если взведен флаг обновления - делается попытка обработать запрос, для чего формируется событие _onBeforeFormSave_. Обозреватели этого события должны проверить данные на соответствие своим требованиям и отменить событие если использование таких данных не возможно, опять же, с указанием ошибок.

Наконец, если не было отмены события _onBeforeFormSave_, вызываем процедуры сохранения данных, формируя событие _onAfterFormSave_. Здесь обозреватели не должны отменять событие, но должны (точнее, могут) прикрепить к событию данные "результат работы", например созданный элемент. Само собой, обозреватели могут и сами бросить события в своей предметной области ("новый пользователь", "обновлена анкета" и т.п.)


== Компоненты ==

Первое что нам требуется для реализации модели - обозреватель событий формы. Это должен быть класс, реализующий интерфейс _Oops_Form_Observer_Interface_. Интерфейс задает 3 метода для обработки вышеописанных событий контроллера формы.

Второе - именованный контроллер формы с указанием регулярного диспетчера. Имя контроллера (формы) используется для уточнения названий генерируемых событий - события будут иметь вид _onBeforeИмяФормы!FormShow_, _onBeforeИмяФормы!FormSave_ и _onAfterИмяФормы!FormSave_. Второй параметр конструктора - идентификатор подчиненного диспетчера. Контроллер формы назначает регулярный диспетчер в качестве подчиненного к собственному диспетчеру событий, т.е. при инициализации диспетчера происходит вызов:
{{{
		$dispatcher = Oops_Event_Dispatcher::getInstance($name);
		$this->addNestedDispatcher($dispatcher);
}}}
Такой подход позволяет достаточно гибко назначать слушателей за пределами кода, непосредственно использующего контроллер формы.

Ну и, наконец, нужен интерфейсный класс, использующий эту форму. Интерфейс должен инстанцировать контроллер формы, обозревателей формы, назначить последних слушателями событий формы (метод контроллера _attachObserver_ назначает объект слушателем всех 3х событий). Дальше нужно сформировать массив запроса (или из реального запроса или из его частей или как-либо еще), и запустить контроллер формы с передачей запроса и флага обновления. Пример этого кода приведен в комментарии к классу _Oops_Form_Controller_. Результат работы контроллера можно передать в шаблон или использовать как-либо еще.
{{{
$formController = new Oops_Form_Controller('ObjectCreate');
$objectCreator = new Some_Class_Creator($someParams); //must implement Oops_Form_Observer_Interface
$request = $this->_request;

$doUpdate = (bool) $this->_request->doUpdate;
$formController->attachObserver($objectCreator);
$result = $formController->action($request, $doUpdate);
}}}



==Результат работы контроллера форм==

Сабж складыватся из массива флагов, ошибок и данных прикрепленных обозревателями.

Флаги это:

    * _flagUpdate_ - был ли флаг обновления (остается false если было отменено событие _onBeforeShowForm_, т.е. форму показывать нельзя)
    * _flagErrors_ - возникли ли ошибки при обработке - было отменено одно из событий _onBefore_
    * _flagShowForm_ - производный флаг "нужно ли показать форму" - взведен если не было ошибок и не запрошено обновление или если запрошено обновление и возникли ошибки
    * _flagStatus_ - производный флаг - не было ошибок
    * _flagComplete_ - производный флаг - не было ошибок и было обновление, т.е. форма отработала до конца и выполнила свою работу.


Данные располагаются за ключом attached. Данные прикрепленные к каждому из событий последовательно объединяются и в итоге складываются в этот массив.
Ошибки складываются в ключ errors, каждая ошибка это массив состоящий из текстового описания ошибки (суть кода) и сопровождающих данных в произвольном формате (т.е. на выбор обозревателя).

==Как реализуется каптча==

Очевидно что каптча может требоваться во многих формах, и проверять ее в каждом аналогичном обозревателе неудобно, особенно если потребуется изменить класс каптчи.
Поэтому делаем так: есть обозреватель каптчи Oops_Form_Captcha_Observer. Инстанцируем его с указанием поля в запросе которое должно содержать код, и следует ли показывать каптчу зарегистрированным пользователям, и... все.
Пример кода для создания объекта реестра:


{{{
// Создаем контроллер формы
   $formController = new Oops_Form_Controller('RegistryCreate', 'Registry');

// Инстанцируем обозревателя который создает анкету
    $registryCreator = new Registry_Object_Creator();

// Прикручиваем
    $formController->attachObserver($registryCreator);

// Прикручиваем каптчу
    $formController->attachObserver(new Oops_Form_Kcaptcha_Observer('captcha'));

// Запускаем форму
    $this->Data = $formController->action($this->_request, (bool) $this->_request->doUpdate);
}}}

Т.е. в таком подходе прикрутить каптчу к форме означает буквально "прикрутить каптчу к форме". Аналогично прикручивается бан и тому подобные функции.

Можно и более изощренно подойти к вопросу каптчи и бана - назначить их слушателями событий в регулярного диспетчера. Тогда в интерфейсном классе не нужно вообще ничего делать, а это значит что интерфейсный класс даже не подозревает что его проверяют извне.
Так, например может работать бан по IP - прописывается на любые формы и запрещает их показывать.